package unimelb.bitbox.peer;

import unimelb.bitbox.util.Configuration;
import unimelb.bitbox.util.FileSystemManager;
import unimelb.bitbox.util.HostPort;

import java.net.Socket;
import java.util.ArrayList;
import java.util.logging.Logger;

public class TCPPeerManager implements ConnectionObserver {
    private static Logger log = Logger.getLogger(ConnectionObserver.class.getName());

    public final int MAX_INCOMING_CONNECTIONS;
    private ArrayList<Connection> peers;
    private int nIncomingConnections;


    private static TCPPeerManager ourInstance = new TCPPeerManager();

    public static TCPPeerManager getInstance() {
        return ourInstance;
    }

    private TCPPeerManager() {
        peers = new ArrayList<>();
        nIncomingConnections = 0;
        MAX_INCOMING_CONNECTIONS = Integer.parseInt(Configuration.getConfigurationValue("maximumIncommingConnections"));
    }

    /**
     * Connect to a specific peer
     * @param fileSystemManager
     * @param remoteHostPortString
     */
    public void connect(FileSystemManager fileSystemManager, String remoteHostPortString) {
        peers.add(new OutgoingConnection(fileSystemManager, this, new HostPort(remoteHostPortString)));
    }

    /**
     * Accept a peer from a peer
     * @param fileSystemManager
     * @param socket
     */
    public void accept(FileSystemManager fileSystemManager, Socket socket) {
        nIncomingConnections++;
        peers.add(new IncomingConnection(fileSystemManager, this, socket));
    }

    /**
     * A peer is closed, so remove it from the list of connections
     * If it is an incoming peer, reduce nIncomingConnections
     * @param connection
     * @param isIncoming
     */
    @Override
    public void closeConnection(Connection connection, boolean isIncoming) {
        if (isIncoming) {
            nIncomingConnections--;
        }
        peers.remove(connection);

        log.info("successfully closed peer");
        log.info(peers.size() + " peers currently connected");
    }

    public void closeConnection(HostPort remoteHostPort, boolean isIncoming) {
        int index = 0;
        for(Connection connection: peers) {
            if (connection.remoteHostPort.equals(remoteHostPort)) {
                break;
            }
            index++;
        }

        if (index < peers.size()) {
            if (isIncoming) {
                nIncomingConnections--;
            }

            Connection removed = peers.remove(index);
            removed.close();

            log.info("successfully closed peer");
            log.info(peers.size() + " peers currently connected");
        }

    }


    @Override
    public void retry(Connection connection) {
        log.info("retrying peer..");
        connect(connection.fileSystemManager, connection.remoteHostPort.toString());
    }

    /**
     * Get a list of HostPorts from peers
     */
    public ArrayList<HostPort> getPeersHostPorts() {
        ArrayList<HostPort> hostPorts = new ArrayList<>();
        for (Connection peer : peers) {
            if (peer.remoteHostPort != null) {
                hostPorts.add(peer.remoteHostPort);
            }
        }

        return hostPorts;
    }

    /**
     * Returns true if the peer is successfully connected else it is false
     * @param remoteHostPort
     * @return
     */
    public Connection.STATE getPeerState(HostPort remoteHostPort) {
        for (Connection peer: peers) {
        	if (peer.remoteHostPort == null) {
            	continue;
            }
            if (peer.remoteHostPort.equals(remoteHostPort)) {
                return peer.getState();
            }
        }

        return null;
    }

    /**
     * Process a file system event generated by the system and send it to all the peers
     * @param fileSystemEvent
     */
    public void processFileSystemEvent(FileSystemManager.FileSystemEvent fileSystemEvent) {
        for (Connection peer : peers) {
            peer.processFileSystemEvent(fileSystemEvent);
        }
    }

    /**
     * Returns true if still able to accept incoming connections
     * @return
     */
    public boolean isAvailableConnections() {
        return nIncomingConnections <= MAX_INCOMING_CONNECTIONS;
    }
}
